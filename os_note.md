## 重要链接

【MAC下安装实验环境】

https://github.com/chyyuu/ucore_os_lab/issues/19

【操作系统基本问答】

https://xuyongjiande.gitbooks.io/os-qa/content/01-intro.html

## 启动流程

1. CPU加上电，稳定以后：

从 CS:IP = 0xf000:0xfff0读取第一条指令。此时PC = 16 * CS + IP = 0xffff0.这是一条跳转指令，跳转到BIOS。

原因：此时是实模式，地址只有20位，寄存器只有16位，所以寻址方式是CS * 16 + IP.

2. BIOS初始化。

硬件自检

设备初始化

执行系统BIOS，进行系统检测

更新CMOS中扩展系统配置的ESCD

从设备上读入第一个扇区（主引导记录MBR）

##### 主引导记录

启动代码446字节：检测分区表正确性，加载并跳转到磁盘上的引导程序。

分区表64字节：

结束标志：0x55AA

##### 分区引导记录格式

跳转指令，到启动代码

文件卷头信息

结束标志（0x55AA）

##### 加载程序（bootloader）

从文件系统中读取启动配置、启动菜单、依据配置加载内核并跳转执行。


## 中断、异常、系统调用

#### 系统调用和函数调用的开销

系统调用的多余的开销包括 堆栈切换，

## 段机制

地址映射、权限控制

### 段选择子

段选择子用来选择一个段，记录了index和权限级别。

### 全局描述符表 GDT

是一个数组，通过段选择子中的index进行访问。表中记录了段基地址，段大小等。

## x86 中断处理

中断发生-根据中断号查找中断描述表IDT-查找得到段选择子-查找GDT-指向中断服务程序（ISR）

无特权级别切换时候的堆栈变化：

依次压入Error Code, EIP（当前运行地址）, CS, EFLAGS（异常中的一些标志性内容）

恢复执行：弹出栈，恢复相关信息

产生了特权级别变化（用户态-》内核态）

用户态的栈不发生变化，切换到内核状态的栈多了用户态的：ESP和SS

### 地址空间

逻辑地址生成的时机：

1. 编译时，假设起始地址是已知的。

2. 编译器需要生成可重定位的代码，在加载时生成绝对地址。

3. 执行时，需要硬件地址转换支持，优点在于执行时可以移动代码块位置。

### 地址检查

CPU给出逻辑地址，通过段长寄存器检查长度是否小于最大值。

### 连续内存分配

给进程分配连续的，不小于指定大小的内存空间。

内存碎片：

1. 外部碎片：两个进程之间的无法利用的空间。

2. 内部碎片：由于分配大小不合适造成的，例如申请510字节，返回了512字节。


1. 最先匹配 First Fit

空闲分区列表按照地址排序，分配时找到第一个满足条件的，释放时只用检查临近的区域。
优点是简单，缺点是有外碎片

2. 最佳匹配 Best Fit

空闲分区按照大小排序，分配时从头开始查找列表寻找满足条件的，释放时遍历整个列表。
优点：大部分分配的尺寸小时，效果很好（可以避免大的空闲分区被拆分，减少外碎片的大小）；相对简单
缺点：会产生外部碎片，释放较慢。

3. 最差匹配 Worse fit

空闲分区按照由大到小排序，分配时从前向后找，释放时寻找临近的合并。

优点：中等尺寸分配效果较好。避免出现太多的小碎片。

缺点：外部碎片，容易破坏大分区。释放较慢。后期难以处理大空闲内存的申请。

### 碎片整理

#### 1. 碎片整理：紧凑

通过调整进程占用的位置来减少碎片。

条件：

1. 所有应用程序都是可以重定位的。

需要解决的问题：

1. 什么时候移动。

2. 移动的开销。

#### 2. 碎片整理：分区兑换

抢占等待状态进程的分区，将其换到外存中，增加可用内存区间。

#### 伙伴系统

整个可分配分区的大小是2的幂次方

每次分配的分区大小也是2的幂次，如果待分配分区小于空闲的二分之一，就对半分。合并：大小必须一样，地址是相邻的，低地址的起始地至需要是2的幂次。

### 非连续内存分配

连续内存分配的缺点

1. 分配给程序的威力内存必须连续

2. 存在内碎片和外碎片

3. 内存分配的动态修改困难

4. 内存利用率低

设计目标：

1. 允许非连续的物理地址

2. 允许共享代码和数据（例如函数库）

3. 支持动态加载和动态链接

#### 段式内存管理

访问方式和存储数据属性相同的一段地址空间，对应于一个连续的内存块。

段地址空间：主程序段，子模块段，公用库代码段，堆栈段，堆数据段……

段访问：逻辑地址由二元组组成（段号，段内偏移）。

段号查询段描述符得到段基地址，加上段内偏移。

#### 页式存储管理

页帧（物理地址）：将物理地址空间划分为相通大小的基本分配单位（一般是2的幂次）。

物理内存的表示：(f, o)。帧号（F位），帧内偏移。

页面（逻辑地址）：进程的逻辑地址空间也被划分成相等大小的页。
进程逻辑地址的转换（p, o)。

将页面对应到页帧使用页表进行。页表保存了逻辑地址和物理地址的映射关系。通过逻辑页号和页表基地址相加，得到对应的帧号，再加上页内偏移。

1. bootloader加载ucore的结束地址：用全局指针变量end记录。使用这个地址（按页的大小取正以后）作为页表的开始地址。

2. 

### 页表

内存访问性能问题：

1. 访问一次内存单元需要两次内存访问（第一次页表象，第二次访问数据）

2. 页表大小问题：页表可能非常大。

如何处理：

1. 缓存。快表，下一次访问的时候可能会访问到同一个页表。

2. 间接访问。即多级页表。

缓解页表的困难：快表，多级页表，反置页表

#### 页表的实现

1. 使用页表进行地址转换

首先从线性地址开始，即经过了段机制的转换。它是32位的，高10位用作index在一级页表PD中查找（PDX(addr）)。

PD中查到到了页目录项，它记录了对应二级页表的起始地址（20位）。

用线性地址的下面10位来查找页表，得到20位的物理页号。

页目录和页表都是以一个页为单位的（4K大小，$2^{10}$个）

一个表象是32位，其余位存了各种属性。

R/W, User/System, Access

2. 

#### 快表（TLB）

近期访问的页表项缓存到CPU中（关联存储器）。

#### 多级页表

通过间接引用将页表分成K级，也就是将逻辑地址分段。

CR3寄存器指向了一级页表（Page Table）的起始位置，然后依次进行查询。

#### 反置页表

大地址空间问题

##### 1. 页寄存器：每一个物理帧与一个页寄存器关联：使用位，占用页号，保护位。页寄存器和虚拟地址空间无关。

优点：

1. 页表大小相对于物理内存很小。

2. 页表大小与逻辑地址空间无关。

缺点：

1. 页表信息对掉后，可根据帧号找到页号。

2. 在页寄存器中搜索页号。

地址转换：

对逻辑地址进行Hash，减少搜索范围。

可以结合快表进行优化，

##### 2. 反置页表

把进程标志与地址一起进行哈希，进入到一个索引表中，根据索引表找到对应的表象，判断进程ID和页号是否一致，不一致则按照哈希冲突链表的方式找到下一个位置。

### 段页式内存管理

段式在内存保护上有优势。

给每一个段加一个页表。

逻辑地址变成：段号 页号 页内偏移

首先通过段机制找到段表象，进而找到对应的页表基址。

内存共享：通过指向相同的页表基址实现内存间的段共享。

### x86的特权级

x86一共有4个特权级。检查特权级的时刻：访问数据段

段选择子：index+DPL;

段描述符：DPL。

门描述符：DPL。

RPL处于数据段：DS, ES, FS, GS

CPL处于CS， SS

访问门的时候：CPL ≤ DPL[门] & CPL ≥ DPL[段]
（通过门的目的是为了访问等高级的代码）

访问段：MAX(CPL, RPL) ≤ DPL[段]

### 特权级切换

通过中断切换特权级。

#### 通过构造特殊的栈来从内核态切换到用户态：

1. 进入到内核态之后，压入了CS(CPL=0)

2. 修改CS(CPL=3)

3. 弹出栈（调用iret）

#### 通过用户态切换到内核态：

软中断即可。产生中断之后就完成了特权级别的切换。

想要继续留在内核态，就将CS(CPL=3)设置为CS(CPL=0)。

### TSS格式

堆栈的信息在切换态的时候是没有的。通过TSS找到。

TSS其中有从ring0~ring2的堆栈信息（SS和ESP），在GDT中可以找到TSS的地址。

使用TSS：

1. Task Register中：index, 基址，段长度限制。TR也是用来缓存的。

2. TR中index到GDT中的一项，TSS Descriptor 其中有TSS的地址。

建立TSS：

1. 为TSS分配内存。

2. 初始化。

3. 在GDT中填写TSS Descriptor。

4. 设置TSS 选择子。

### 使能

对CR0置位来使能页机制。


建立页表：

1. 分配一个页用于建立页目录表

2. 清空这个页

3. Map 0xC0000000 - 0xF8000000 (VA) to 0x00000000 - 0x3800000 (PA)

4. Map 0x00000000 - 0x00100000 (VA) to 0x00000000 - 0x00100000 (PA)

5. Set CR3 & bit 31 of CR0

6. Update GDT

7. Unmap 0x00000000 - 0x00100000 (VA) to 0x00000000 - 0x00100000 (PA)

【为什么要取消】？


### 页面置换算法

#### LRU

#### 时钟置换算法

特征：LRU和FIFO的折中。

装入内存：访问为初始化为零

访问页面时，访问位置1

缺页时，访问为0则置换页面；为1则清零，跳过。

### 改进的Clock算法

减少修改页的缺页处理开销

在页面增加修改位

使用位 修改位 使用位 修改位
0 0     置换
0 1     0 0
1 0     0 0
1 1     0 1

#### Belady 现象

可分配的物理页面增加，缺页次数反而增加。

FIFO算法有Belady现象。

LRU没有Belady现象。

### 全局置换算法

局部置换算法没有考虑到进程的方寸差异

给进程分配可变数目的物理页面

工作集：进程当前正在使用的逻辑页面集合$W(t, \delta)$

当前时刻和工作集时间窗口

#### 工作集置换算法

局部位置稳定时

局部位置改变的时候，会快速扩展和收缩工作集

常住集：系统给进程分配的物理页数

换出不在工作集中的页面。维护窗口内的方寸页面连标，方寸时，患处不在工作集的页面，更新方寸连标。缺页时，换入页面，更新方寸连标。

### 

缺页率：缺页次数/内存访问次数

通过调节常住集大小，使每个进程的缺页旅保持

引用标志为。

缺页时，根据缺页时间到现在时间的间隔，如果大于阈值，就将所有没有被引用的页置换出去。

#### 负载控制

通过控制并发进程数

最好：缺页平均间隔时间 = 缺页异常处理时间


#### 进程

进程：独立功能的程序在数据集合上动态执行

源代码 -> 栈、堆、代码段

动态性：动态地创建、执行

并发性：交错执行

独立性：不同进程之间部相互影响

制约性：因为访问共享数据资源和进程之间同步产生制约

程序 = 文件；进程 = 执行中的程序 = 程序 + 执行状态

同一个程序的多次执行是多个进程

程序是永久的，进程是暂时的

进程：程序、数据、进程控制块

所需资源：内存和CPU

#### PCB

进程控制快PCB 管理控制进程所用的信息合集

进程存在的唯一标志

1. 进程创建：生成进程的PCB

2. 进程中指：回收PCB

3. 进程管理：通过对PCB管理实现。

进程标志信息、处理机的现场保护、进程控制信息

PC, SP, 寄存器,PID, UID，调度优先级...

调度和状态信息

进程间通讯信息

存储管理信息

进程所用资源

有关数据结构的链接信息（进程队列）

就绪链表、等待链表。或者索引表。

#### 进程状态

生命周期：创建、执行、等待、抢占、唤醒、结束。

创建 -> 就绪 -> 运行 -> （启动了操作...）等待

                |  -> 高优先级进程就绪，进程执行时间用完

                |  -> 退出（正常，错误（资源），致命，被其他进程斩杀（强制））

进程被唤醒：条件满足。

内核如何选择就绪的进程进行执行：进程调度

#### 三状态进程模型

运行、等待、就绪

创建和退出是辅助状态

就绪-》运行：程序被选中。

#### 挂起进程模型

进程映像在磁盘上

就绪挂起、等待挂起

挂起：把一个进程从内存转到外存中

等待到等待挂起：没有进程处于就绪状态，或就绪进程要求更多的内存资源。

就绪到就绪挂起：高优先级等待进程

运行到就绪挂起：高优先级等待进程进入就绪状态，导致低优先级挂起。

激活：外存到内存。

就绪挂起就绪

等待挂起到等待：前一个进程释放了大量的空间。

#### 线程

线程是进程的一部分，描述指令流执行状态。是CPU调度的基本单位。

进程是资源分配的角色。

##### 用户线程

通过用户界别的线程库来实现线程的创建、终止

同步和调度。操作系统内部不感受到用户态的线程。

特征：

1. 不依赖于操作系统的内核。

2. 在用户空间实现的线程机制。每一个进程有私有的线程控制块，TCB由线程库函数维护。

3. 同一进程内线程切换的速度快。无需用户态、和心态的切换。

4. 允许每个进程拥有自己的线程调度算法。

1. 线程发起系统调用而阻塞时，整个进程进入等待。

2. 不支持基于线程的处理机抢占。除非当前线程主动放弃，其他线程无法抢占CPU。

3. 只能按进程分配CPU时间。

内核线程：通过系统调用穿件线程

由内核来维护PCB和TCB

线程的创建、终止、切换的代价相对较大

轻权进程：一个进程可以有一个或多个轻量级进程，每一个清泉进程由一个单独的内核线程支持。

#### 进程切换

暂停当前进程，从运行状态变成其他状态，调度另一个进程变成运行状态。需要保存进程上下文，回复上下文。需要做到快速切换。

需要保存：寄存器，CPU状态，内存地址空间。

【CR3】,堆栈

内存地址空间结构：第一级页表的起始地址，置换外存的相关机构

fork 复制进程。

子进程返回0，夫进程返回紫禁城id

进程加载：exec（）

夹在一个完全不同

相同的进程，运行了不同的程序